1. A library doesn't have to be large or complicated to be useful;
2. Time your programs before making claims about efficiency;
3. Use duration_cast to report time measurements with proper units;
4. To represent a date directly in source code, use symbolic notation (e.g., November/28/2021);
5. If a date is a result of a computation, check for validity using ok();
6. When dealing with time in different locations, use zoned_time;
7. Use a lambda to express minor changes in calling conventions;
8. Use mem_fn() or a lambda to create function objects that can invoke a member function when called using the traditional function call notation;
9. Use function when you need to store something that can be called;
10. Prefer concepts to explicit use of type predicates;
11. You can write code to explicitly depend on properties of types;
12. Prefer concepts over traits and enable_if whenever you can;
13. Use source_location to embed source code locations in debug and logging messages;
14. Avoid explicit use of std::move();
15. Use std::forward() exclusively for forwarding;
16. Never read from an object after std::move()ing or std::forward()ing it;
17. Use std::byte to represent data that doesn't (yet) have a meaningful type;
18. Use unsigned integers or bitsets for bit manipulation;
19. Return an error-code from a function if the immediate caller can be expected to handle the problem;
20. Throw an exception from a function if the immediate caller cannot be expected to handle the problem;
21. Call exit(), quick_exit(), or terminate() to exit a program if an attempt to recover from a problem is not reasonable;
22. No general-purpose library should unconditionally terminate;