1. An STL container defines a sequence;
2. STL containers are resource handles;
3. Use vector as your default container;
4. For simple traversals of a container, use a range-for loop or a begin/end pair of iterators;
5. Use reserve() to avoid invalidating pointers and iterators to elements;
6. Don't assume performance benefits from reserve() without measurement;
7. Use push_back() or resize() on a container rather than realloc() on an array;
8. Don't use iterators into a resized vector;
9. Do not assume that [] range checks;
10. Use at() when you need guaranteed range checks;
11. Use range-for and standard-library algorithms for cost-free avoidance of range errors;
12. Elements are copied into a container;
13. To preserve polymorphic behavior of elements, store pointers (built-in or user-defined);
14. Insertion operations, such as insert() and push_back(), are often surprisingly efficient on a vector;
15. Use forward_list for sequences that are usually empty;
16. When it comes to performance, don't trust your intuition: measure;
17. A map is usually implemented as a red-black tree;
18. An unordered_map is a hash table;
19. Pass a container by reference and return a container by value;
20. For a container, use the ()-initializer syntax for sizes and the {}-initializer syntax for sequences of elements;
21. Prefer compact and contiguous data structures;
22. A list is relatively expensive to traverse;
23. Use unordered containers if you need fast lookup for large amounts of data;
24. Use ordered containers (e.g., map and set) if you need to iterate over their elements in order;
25. Use unordered containers (e.g., unordered_map) for element types with no natural order (i.e., no reasonable <);
26. Use associative containers (e.g., map and list) when you need pointers to elements to be stable as the size of the container changes;
27. Experiment to check that you have an acceptable hash function;
28. A hash function obtained by combining standard hash functions for elements using the exclusive-or operator (^) is often good;
29. Know your standard-library containers and prefer them to handcrafted data structures;
30. If your application is suffering performance problems related to memory, minimize free store use and/or consider using a specialized allocator;