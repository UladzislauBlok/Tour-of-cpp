1. Use std::string to own character sequences;
2. Prefer string operations to C-style string functions;
3. Use string to declare variables and members rather than as a base class;
4. Return strings by value (rely on move semantics and copy elision);
5. Directly or indirectly, use substr() to read substrings and replace() to write substrings;
6. A string can grow and shrink, as needed;
7. Use at() rather than iterators or  . when you want range checking;
8. Use iterators and  . rather than at() when you want to optimize speed;
9. Use a range-for to safely minimize range checking;
10. string input doesn't overflow;
11. Use c_str() or data() to produce a C-style string representation of a string (only) when you have to;
12. Use a stringtream or a generic value extraction function (such as to<X>) for numeric conversion of strings;
13. A basic_string can be used to make strings of characters on any type;
14. Use the s suffix for string literals meant to be standard-library strings;
15. Use string_view as an argument of functions that needs to read character sequences stored in various ways;
16. Use string_span<char> as an argument of functions that needs to write character sequences stored in various ways;
17. Think of a string_view as a kind of pointer with a size attached;
18. Use the sv suffix for string literals meant to be standard-library string_views;
19. Use regex for most conventional uses of regular expressions;
20. Prefer raw string literals for expressing all but the simplest patterns;
21. Use regex_match() to match a complete input;
22. Use regex_search() to search for a pattern in an input stream;
23. The regular expression notation can be adjusted to match various standards;
24. The default regular expression notation is that of ECMAScript;
25. Be restrained;
26. Note that \i for a digit i allows you to express a subpattern in terms of a previous subpattern;
27. Use ? to make patterns 'lazy';
28. Use regex_iterators for iterating over a stream looking for a pattern;