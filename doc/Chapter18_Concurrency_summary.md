1. Use concurrency to improve responsiveness or to improve throughput;
2. Work at the highest level of abstraction that you can afford;
3. Consider processes as an alternative to threads;
4. The standard-library concurrency facilities are type safe;
5. The memory model exists to save most programmers from having to think about the machine architecture level of computers;
6. The memory model makes memory appear roughly as naively expected;
7. Atomics allow for lock-free programming;
8. Leave lock-free programming to experts;
9. Sometimes, a sequential solution is simpler and faster than a concurrent solution;
10. Avoid data races;
11. Prefer parallel algorithms to direct use of concurrency;
12. A thread is a type-safe interface to a system thread;
13. Use join() to wait for a thread to complete;
14. Prefer jthread over thread;
15. Avoid explicitly shared data whenever you can;
16. Prefer RAII to explicit lock/unlock;
17. Use scoped_lock to manage mutexes;
18. Use scoped_lock to acquire multiple locks;
19. Use shared_lock to implement reader-write locks;
20. Define a mutex together with the data it protects;
21. Use atomics for very simple sharing;
22. Use condition_variables to manage communication among threads;
23. Use unique_lock (rather than scoped_lock) when you need to copy a lock or need lower-level manipulation of synchronization;
24. Use unique_lock (rather than scoped_lock) with condition_variables;
25. Don't wait without a condition;
26. Minimize time spent in a critical section;
27. Think in terms of concurrent tasks, rather than directly in terms of threads;
28. Value simplicity;
29. Prefer packaged_tasks and futures over direct use of threads and mutexes;
30. Return a result using a promise and get a result from a future;
31. Use packaged_tasks to handle exceptions thrown by tasks;
32. Use a packaged_task and a future to express a request to an external service and wait for its response;
33. Use async() to launch simple tasks;
34. Use stop_token to implement cooperative termination;
35. A coroutine can be very much smaller than a thread;
36. Prefer coroutine support libraries to hand-crafted code;