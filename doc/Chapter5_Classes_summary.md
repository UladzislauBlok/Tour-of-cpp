1. Express ideas directly in code;
2. A concrete type is the simplest kind of class. Where applicable, prefer a concrete type over more complicated classes and over plain data structures;
3. Use concrete classes to represent simple concepts;
4. Prefer concrete classes over class hierarchies for performance-critical components;
5. Define constructors to handle initialization of objects;
6. Make a function a member only if it needs direct access to the representation of a class;
7. Define operators primarily to mimic conventional usage;
8. Use nonmember functions for symmetric operators;
9. Declare a member function that does not modify the state of its object const;
10. If a constructor acquires a resource, its class needs a destructor to release the resource;
11. Avoid ‘naked’ new and delete operations;
12. Use resource handles and RAII to manage resources;
13. If a class is a container, give it an initializer-list constructor;
14. Use abstract classes as interfaces when complete separation of interface and implementation is needed;
15. Access polymorphic objects through pointers and references;
16. An abstract class typically doesn’t need a constructor;
17. Use class hierarchies to represent concepts with inherent hierarchical structure;
18. A class with a virtual function should have a virtual destructor;
19. Use override to make overriding explicit in large class hierarchies;
20. When designing a class hierarchy, distinguish between implementation inheritance and interface inheritance;
21. Use dynamic_cast where class hierarchy navigation is unavoidable;
22. Use dynamic_cast to a reference type when failure to find the required class is considered a failure;
23. Use dynamic_cast to a pointer type when failure to find the required class is considered a valid alternative;
24. Use unique_ptr or shared_ptr to avoid forgetting to delete objects created using new;
