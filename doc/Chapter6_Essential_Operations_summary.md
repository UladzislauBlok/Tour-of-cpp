1. Control construction, copy, move, and destruction of objects;
2. Design constructors, assignments, and the destructor as a matched set of operations;
3. Define all essential operations or none;
4. If a default constructor, assignment, or destructor is appropriate, let the compiler generate it;
5. If a class has a pointer member, consider if it needs a user-defined or deleted destructor, copy and move;
6. If a class has a user-defined destructor, it probably needs user-defined or deleted copy and move;
7. By default, declare single-argument constructors explicit;
8. If a class member has a reasonable default value, provide it as a data member initializer;
9. Redefine or prohibit copying if the default is not appropriate for a type;
10. Return containers by value (relying on copy elision and move for efficiency);
11. Avoid explicit use of std::copy();
12. For large operands, use const reference argument types;
13. Provide strong resource safety; that is, never leak anything that you think of as a resource;
14. If a class is a resource handle, it needs a user-defined constructor, a destructor, and nondefault copy operations;
15. Manage all resources – memory and non-memory – resources using RAII;
16. Overload operations to mimic conventional usage;
17. If you overload an operator, define all operations that conventionally work together;
18. If you define <=> for a type as non-default, also define ==;
19. Follow the standard-library container design;