1. A library doesn't have to be large or complicated to be useful;
2. A resource is anything that has to be acquired and (explicitly or implicitly) released;
3. Use resource handles to manage resources (RAII);
4. The problem with a T* is that it can be used to represent anything, so we cannot easily determine a 'raw' pointer's purpose;
5. Use unique_ptr to refer to objects of polymorphic type;
6. Use shared_ptr to refer to shared objects (only);
7. Prefer resource handles with specific semantics to smart pointers;
8. Don't use a smart pointer where a local variable will do;
9. Prefer unique_ptr to shared_ptr;
10. use unique_ptr or shared_ptr as arguments or return values only to transfer ownership responsibilities;
11. Use make_unique() to construct unique_ptrs;
12. Use make_shared() to construct shared_ptrs;
13. Prefer smart pointers to garbage collection;
14. Prefer spans to pointer-plus-count interfaces;
15. span supports range-for;
16. Use array where you need a sequence with a constexpr size;
17. Prefer array over built-in arrays;
18. Use bitset if you need N bits and N is not necessarily the number of bits in a built-in integer type;
19. Don't overuse pair and tuple;
20. When using pair, use template argument deduction or make_pair() to avoid redundant type specification;
21. When using tuple, use template argument deduction or make_tuple() to avoid redundant type specification;
22. Prefer variant to explicit use of unions;
23. When selecting among a set of alternatives using a variant, consider using visit() and overloaded();
24. If more than one alternative is possible for a variant, optional, or any, check the tag before access;