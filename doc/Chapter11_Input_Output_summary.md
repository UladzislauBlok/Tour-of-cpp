1. iostreams are type-safe, type-sensitive, and extensible;
2. Use character-level input only when you have to;
3. When reading, always consider ill-formed input;
4. Avoid endl (if you don't know what endl is, you haven't missed anything);
5. Define << and >> for user-defined types with values that have meaningful textual representations;
6. Use cout for normal output and cerr for errors;
7. There are iostreams for ordinary characters and wide characters, and you can define an iostream for any kind of character;
8. Binary I/O is supported;
9. There are standard iostreams for standard I/O streams, files, and strings;
10. Chain << operations for a terser notation;
11. Chain >> operations for a terser notation;
12. Input into strings does not overflow;
13. By default >> skips initial whitespace;
14. Use the stream state fail to handle potentially recoverable I/O errors;
15. We can define << and >> operators for our own types;
16. We don't need to modify istream or ostream to add new << and >> operators;
17. Use manipulators or format() to control formatting;
18. precision() specifications apply to all following floating-point output operations;
19. Floating-point format specifications (e.g., scientific) apply to all following floating-point output operations;
20. #include <ios> or <iostream> when using standard manipulators;
21. Stream formatting manipulators are 'sticky' for use for many values in a stream;
22. #include <iomanip> when using standard manipulators taking arguments;
23. We can output time, dates, etc. in standard formats;
24. Don't try to copy a stream: streams are move only;
25. Remember to check that a file stream is attached to a file before using it;
26. Use stringstreams or memory streams for in-memory formatting;
27. We can define conversions between any two types that both have string representation;
28. C-style I/O is not type-safe;
29. Unless you use printf-family functions call ios_base::sync_with_stdio(false);
30. Prefer <filesystem> to direct use of platform-specific interfaces;